// --- Basic Scene Setup ---
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);
camera.position.z = 10;

// --- Starfield Background (runs on all pages) ---
const starGeometry = new THREE.BufferGeometry();
const starVertices = [];
for (let i = 0; i < 15000; i++) {
    const x = (Math.random() - 0.5) * 2000;
    const y = (Math.random() - 0.5) * 2000;
    const z = -Math.random() * 2000;
    starVertices.push(x, y, z);
}
starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
const stars = new THREE.Points(starGeometry, new THREE.PointsMaterial({ color: 0xffffff, size: 0.7 }));
scene.add(stars);

// --- Homepage-Specific Logic for 3D Blocks ---
const blocks = [];
// The homepage is the only page that WON'T have the iframe-container div.
// This is how we detect if we should create the blocks.
if (!document.querySelector('.iframe-container')) {
    // In a real project, this data would come from a JSON file generated by Eleventy.
    // For setup, we will use a placeholder. Eventually this will be dynamic.
    const pages = [
        { "title": "My First Project", "url": "/page-one/" }, // Eleventy creates clean URLs
        { "title": "Another Cool App", "url": "/page-two/" }
    ];

    pages.forEach((page, index) => {
        const geometry = new THREE.BoxGeometry(2, 2, 2);
        const material = new THREE.MeshBasicMaterial({ color: 0x00aaff, wireframe: true });
        const cube = new THREE.Mesh(geometry, material);

        // Position the cubes in a grid
        cube.position.x = (index % 4 - 1.5) * 4;
        cube.position.y = (Math.floor(index / 4)) * -4;

        cube.userData.URL = page.url; // Store the page URL in the cube object
        blocks.push(cube);
        scene.add(cube);
    });

    // --- Interactivity for clicking blocks ---
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    window.addEventListener('click', (event) => {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(blocks);
        if (intersects.length > 0) {
            // If a block is clicked, go to its URL
            window.location.href = intersects[0].object.userData.URL;
        }
    });
}

// --- Animation Loop (runs on all pages) ---
function animate() {
    requestAnimationFrame(animate);
    stars.rotation.z += 0.0001; // Gently rotate stars

    // Animate blocks only if they exist
    blocks.forEach(block => {
        block.rotation.x += 0.005;
        block.rotation.y += 0.005;
    });

    renderer.render(scene, camera);
}
animate();

// --- Handle Window Resizing (runs on all pages) ---
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
^\
// --- Basic Scene Setup ---
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);
camera.position.z = 15; // Pulled the camera back a bit to see more

// ====================================================================
// NEW: Add Lighting
// ====================================================================
// This light gives a soft, even illumination to the whole scene.
const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
scene.add(ambientLight);

// This light acts like a sun, casting shadows and creating highlights.
const pointLight = new THREE.PointLight(0xffffff, 1.5); // A bright white light
pointLight.position.set(0, 0, 0); // Position it at the center
scene.add(pointLight);


// --- Starfield Background (runs on all pages) ---
const starGeometry = new THREE.BufferGeometry();
const starVertices = [];
for (let i = 0; i < 15000; i++) {
    const x = (Math.random() - 0.5) * 2000;
    const y = (Math.random() - 0.5) * 2000;
    const z = -Math.random() * 2000;
    starVertices.push(x, y, z);
}
starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
const stars = new THREE.Points(starGeometry, new THREE.PointsMaterial({ color: 0xffffff, size: 0.7 }));
scene.add(stars);

// ====================================================================
// NEW: Create a Planet
// ====================================================================
const textureLoader = new THREE.TextureLoader();
// Using a texture from a reliable source. You can replace this with your own.
const earthTexture = textureLoader.load('https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg');

const planetGeometry = new THREE.SphereGeometry(1.5, 32, 32); // A sphere with a radius of 1.5
// Use MeshStandardMaterial to make it react to light realistically.
const planetMaterial = new THREE.MeshStandardMaterial({ map: earthTexture });
const planetMesh = new THREE.Mesh(planetGeometry, planetMaterial);
scene.add(planetMesh);


// --- Homepage-Specific Logic for 3D Blocks ---
const blocks = [];
if (!document.querySelector('.iframe-container')) {
    const pages = [
        { "title": "My First Project", "url": "/page-one/" },
        { "title": "Another Cool App", "url": "/page-two/" }
    ];

    pages.forEach((page, index) => {
        const geometry = new THREE.BoxGeometry(1, 1, 1); // Made cubes smaller
        const material = new THREE.MeshBasicMaterial({ color: 0x00aaff, wireframe: true });
        const cube = new THREE.Mesh(geometry, material);
        cube.position.x = (index % 4 - 1.5) * 4;
        cube.position.y = (Math.floor(index / 4)) * -4;
        cube.userData.URL = page.url;
        blocks.push(cube);
        scene.add(cube);
    });

    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    window.addEventListener('click', (event) => {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(blocks);
        if (intersects.length > 0) {
            window.location.href = intersects[0].object.userData.URL;
        }
    });
}

// --- Animation Loop (runs on all pages) ---
const clock = new THREE.Clock(); // Use a clock for smooth animation

function animate() {
    requestAnimationFrame(animate);

    const elapsedTime = clock.getElapsedTime(); // Get time passed

    // Animate stars
    stars.rotation.z -= 0.0001;

    // ====================================================================
    // NEW: Animate the planet's orbit and rotation
    // ====================================================================
    planetMesh.rotation.y += 0.002; // Planet spins on its axis

    // Planet orbits in a circle using Math.sin and Math.cos
    planetMesh.position.x = Math.sin(elapsedTime * 0.2) * 8;
    planetMesh.position.z = Math.cos(elapsedTime * 0.2) * 8 - 5; // The -5 pushes the orbit back a bit

    // Animate blocks only if they exist
    blocks.forEach(block => {
        block.rotation.x += 0.005;
        block.rotation.y += 0.005;
    });

    renderer.render(scene, camera);
}
animate();

// --- Handle Window Resizing (runs on all pages) ---
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
